<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>计算机操作系统</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' />
    <link rel="stylesheet" href="../css/index.css">
    <!--引入bootstrap-->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">
    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap.min.js"></script>
</head>
<body class='typora-export os-windows' >
<div>
    <ul class="nav nav-pills" style="margin-left:10%">
        <li role="presentation"><a href="nodejs学习笔记.html">nodejs</a></li>
        <li role="presentation"><a href="react笔记.html">react</a></li>
        <li role="presentation"><a href="心理课笔记.html">psychological</a></li>
        <li role="presentation" class="active"><a href="计算机操作系统.html">Computer operating system</a></li>
        <li role="presentation"><a href="express.html">Express</a></li>
    </ul>
</div>
<div  id='write'  class = 'is-node'><ul><li><p><span>cpu指令</span></p><ul><li><p><span>add(R1 ,R2)</span></p><ul><li><p><span>运算器</span></p></li><li><p><span>控制器</span></p><ul><li><span>开关</span></li><li><span>电流速度</span></li></ul></li></ul></li></ul></li><li><p><span>计算机的核心</span></p><ul><li><p><span>算数运算</span></p></li><li><p><span>逻辑运算</span></p></li><li><p><span>load，</span></p></li><li><p><span>jump   </span></p><ul><li><span>跳转执行</span></li></ul></li><li><p><span>stool(储存)</span></p></li></ul></li><li><p><span>内存管理</span></p><ul><li><p><span>内存</span></p><ul><li><p><span>堆栈</span></p><ul><li><p><span>堆</span></p><ul><li><span>用来分配未知的数据</span></li></ul></li><li><p><span>储存和读取比较麻烦</span></p></li><li><p><span>栈</span></p><ul><li><span>储存固定的数据</span></li><li><span>长度是数据长度是一样的</span></li><li><span>先进后出后进先出</span></li><li><span>读取和储存方便</span></li><li><span>释放内存更简单</span></li></ul></li></ul></li><li><p><span>代码</span></p><ul><li><span>储存代码文本代码中的变量名指向数据块中的地址</span></li></ul></li><li><p><span>数据</span></p><ul><li><span>储存变量等数据</span></li></ul></li></ul></li><li><p><span>libc</span></p><ul><li><span>语言编译后执行libc中的函数</span></li></ul></li></ul></li><li><p><span>文件管理</span></p><ul><li><p><span>储存设备</span></p><ul><li><span>磁盘</span></li><li><span>固态硬盘</span></li></ul></li></ul></li><li><p><span>储存方式</span></p><ul><li><p><span>通过把文件分为块，每块都有自己的地址</span></p><ul><li><p><span>空闲块</span></p></li><li><p><span>管理空闲块</span></p></li><li><p><span>管理储存数据分为元数据和储存数据</span></p><ul><li><p><span>元数据：文件名，所有者，大小，路径</span></p><ul><li><span>损毁之后会导致数据无法读取</span></li></ul></li><li><p><span>储存数据：纯文本文件数据，，，</span></p></li></ul></li></ul></li><li><p><span>逻辑管理</span></p><ul><li><span>储存的数据比较分散</span></li><li><span>读取和读入的时候需要根据位置来合成离散数据</span></li></ul></li><li><p><span>EXT4</span></p><ul><li><p><span>块1</span></p><ul><li><p><span>超块</span></p></li><li><p><span>描述数据结构，块组</span></p></li><li><p><span>GDT</span></p></li><li><p><span>文件系统</span></p></li><li><p><span>空间块</span></p><ul><li><p><span>管理空闲块</span></p><ul><li><span>位置状态</span></li></ul></li></ul></li><li><p><span>index bit（两个）</span></p><ul><li><p><span>管理元数据块</span></p><ul><li><p><span>状态</span></p><ul><li><span>状态位0空</span></li><li><span>状态位1满</span></li></ul></li></ul></li><li><p><span>管理数据块</span></p></li></ul></li><li><p><span>inode(节点)组成的数组</span></p><ul><li><p><span>储存元数据</span></p><ul><li><p><span>单个inode(结构体)</span></p><ul><li><span>文件名：，，，，</span></li><li><span>大小。。。</span></li><li><span>创建者。。</span></li><li><span>，，，，</span></li><li></li></ul></li></ul></li></ul></li><li><p><span>储存的数据</span></p></li></ul></li><li><p><span>块2</span></p></li><li><p><span>块3</span></p></li></ul></li></ul></li><li><p><span>文件格式</span></p><ul><li><p><span>文件类型</span></p></li><li><p><span>文件的排头</span></p><ul><li><span>格式编码等。。</span></li><li><span>文件数据</span></li></ul></li><li><p><span>建立文档系统</span></p><ul><li><span>mkdir建立文件夹</span></li><li><span>fdisk sdb</span></li></ul></li><li><p><span>mkfs.ext4 sdb1   建立文档系统</span></p><ul><li><span>mount  挂装</span></li><li><span>umount反挂装（弹出）</span></li></ul></li><li><p><span>dmesg  打印系统消息</span></p><ul><li><span>dd  if=sdb/zero of=dev/sdb count=200（分区）</span></li></ul></li><li><p><span>|表示上个执行完之后返回值传给|后面的命令</span></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="第二节复习" class="md-header-anchor"></a><span>第二节复习</span></h4><ul><li><p><span>文件格式</span></p><ul><li><p><span>文件解析</span></p><ul><li><span>hexdump -C -n 16 filename</span></li></ul></li></ul></li><li><p><span>挂载的原理</span></p><ul><li><p><span>挂载了之后就是把U盘的根目录覆盖到系统中的某一个路径</span></p><ul><li><span>打开被覆盖的文件的时候就是打开U盘的根目录</span></li></ul></li></ul></li><li><p><span>apt命令</span></p><ul><li><span>apt search</span></li><li><span>apt install</span></li></ul></li></ul><p>&nbsp;</p><h4><a name="中断处理" class="md-header-anchor"></a><span>中断处理</span></h4><ul><li><p><span>概念</span></p><ul><li><span>cpu正常运行时，事件引起cpu中断正在运行的程序</span></li></ul></li><li><p><span>中断处理函数</span></p><ul><li><span>cpu在收到中断之后会运行中断处理函数</span></li></ul></li><li><p><span>中断源</span></p><ul><li><span>产生中断的地方</span></li></ul></li><li><p><span>中断向量</span></p><ul><li><span>用来形成中断服务的的首地址</span></li></ul></li><li><p><span>中断向量表</span></p><ul><li><span>放在寄存器中的中断源地址</span></li></ul></li><li><p><span>cpu</span></p><ul><li><p><span>中断控制器</span></p><ul><li><span>级联一个外部设备中断器</span></li></ul></li></ul></li><li><p><span>查看设备的中断号</span></p><ul><li><span>cat /proc/interupts</span></li></ul></li><li><p><span>cpu的时钟中断</span></p><ul><li><span>cpu在执行的过程中检查进程的运行时间会自己产生一个时钟中断</span></li></ul></li></ul><p>&nbsp;</p><h4><a name="内存" class="md-header-anchor"></a><span>内存</span></h4><ul><li><p><span>磁盘中的应用程序加载到内存的时候会产生的问题</span></p><ul><li><span>地址分配问题</span></li><li><span>安全问题</span></li><li><span>应用程序的驻留问题</span></li></ul></li><li><p><span>内存中的地址</span></p><ul><li><p><span>程序运行的时候需要把虚拟地址映射到物理内存地址</span></p><ul><li><p><span>操作系统来做这件事</span></p></li><li><p><span>把虚拟地址和物理地址分为页来分配</span></p><ul><li><span>映射原理</span></li><li><span>页的大小是一样的</span></li></ul></li><li><p><span>页表索引</span></p><ul><li><span>P一个比特位，1,表示该虚拟页有物理页</span></li><li><span>M位1表示对应的物理内存页被写过</span></li><li><span>S位1表示为核内存0表示用户内存</span></li><li><span>前20位来区分有多少页</span></li><li><span>后面的位数来分配页中的地址</span></li></ul></li><li><p><span>页表分级</span></p><ul><li><p><span>目录</span></p><ul><li><span>目录项</span></li></ul></li><li><p><span>...</span></p></li><li><p><span>页面</span></p><ul><li><span>页表项</span></li></ul></li><li><p><span>页表</span></p><ul><li><span>分配物理内存</span></li></ul><p>&nbsp;</p><p>&nbsp;</p></li></ul></li></ul></li></ul></li><li><p><span>进程</span></p><ul><li><p><span>概述</span></p><ul><li><span>程序，——静态的代码和数据</span></li><li><span>进程——程序在执行的时候</span></li><li><span>进程状态——程序在执行的时候，计算机的状态</span></li></ul></li><li><p><span>时间片</span></p><ul><li><span>把cpu时间平均进行分割，每个时间称为时间片</span></li><li><span>在程序执行的时候每个时间片可能会执行不同的东西，</span></li></ul></li><li><p><span>结构</span></p><ul><li><span>程序</span></li><li><span>内存</span></li><li><span>资源描述符(文件描述)</span></li><li><span>进程的各种信息：运行时间...</span></li></ul></li><li><p><span>进程树</span></p><ul><li><p><span>idle进程id0——运行在内核中</span></p><ul><li><span>闲置的时候会运行这个进程</span></li></ul></li><li><p><span>init 进程id1——</span></p><ul><li><span>初始化保证程序的安全</span></li></ul></li></ul></li><li><p><span>进程的状态</span></p><ul><li><p><span>R运行状态</span></p><ul><li><span>进程在队列中</span></li></ul></li><li><p><span>S睡眠状态</span></p><ul><li><span>进程在等待事情完成，可以被唤醒</span></li></ul></li><li><p><span>D深度睡眠状态</span></p><ul><li><span>无法被唤醒，减少中</span></li></ul></li><li><p><span>T停止状态</span></p><ul><li><span>可以通过发送SLGSTOP信号给进程来停止进程。SLGCONT信号让进程继续</span></li></ul></li><li><p><span>X死亡状态</span></p><ul><li><span>该状态是返回状态，在任务列表中看不到</span></li></ul></li><li><p><span>Z僵尸状态</span></p><ul><li><span>进程退出，在父进程访问子进程之前，子进程处在僵尸状态</span></li><li><span>父进程调用waitpid方法来获取子进程的信息，之后清理掉僵尸状态</span></li><li><span>如果父进程比子进程先退出子进程就会变成孤儿进程，孤儿进程会交给init程序处理</span></li></ul></li></ul></li></ul></li><li><p><span>线程</span></p><ul><li><p><span>每个进程都有一个主线程和很多其他线程</span></p></li><li><p><span>线程的内存分配</span></p><ul><li><span>主线程从进程开始的时候分好了堆栈</span></li><li><span>其他线程从进程中的堆中分出一块自己的堆栈内存</span></li></ul></li><li><p><span>线程的作用</span></p><ul><li><span>一个进程可以同时做很多事情</span></li><li><span>因为进程与进程之间的内存是分开的互相之间的通信会变的很麻烦，但是进程内的线程之间的通信就能很方便的互相访问</span></li></ul></li><li><p><span>为什么使用线程</span></p><ul><li><span>多个程序的执行</span></li><li><span>不让cpu成为瓶颈</span></li></ul></li><li><p><span>真正的实现多线程执行</span></p><ul><li><span>cpu有多个个核心，在执行的时候可以从分别从内存中取出数据来执行，就实现了多个线程同时执行</span></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><ul><li><p><span>hexdump -C -n 256 4.bmp</span></p><p><span>linux解析文件语法 </span></p><ul><li><p><span>hexdump [选项] [文件名]... </span></p></li><li><p><span>hexdump</span></p><ul><li><span>Linux下的一个二进制文件查看工具，它可以将二进制文件转换为ASCII、八进制、十进制、十六进制格式进行查看. </span></li></ul></li><li><p><span>选项</span></p><ul><li><span>-n length 只格式化输入文件的前length个字节。</span></li><li><span>-C 输出规范的十六进制和ASCII码。</span></li><li><span>-b 单字节八进制显示。</span></li><li><span>-c 单字节字符显示。</span></li><li><span>-d 双字节十进制显示。</span></li><li><span>-o 双字节八进制显示。</span></li><li><span>-x 双字节十六进制显示。</span></li><li><span>-s 从偏移量开始输出。</span></li><li><span>-e 指定格式字符串，格式字符串包含在一对单引号中，格式字符串形如：&#39;a/b &quot;format1&quot; &quot;format2&quot;&#39;。</span></li></ul></li><li><p><span>文件名</span></p></li><li><p><span>bmp文件</span></p></li><li><p><span>典型的BMP 图像文件由四部分组成： 　</span></p><p><span>1 ： 位图文件 头数据结构 ，它包含BMP 图像文件的类型、显示内容等信息；　</span></p><p><span> 　2 ： 位图信息数据结构 ，它包含有BMP 图像的宽、高、压缩方法，以及定义颜色等信息；　　</span></p><p><span>3： 调色板 ，这个部分是可选的，有些位图需要调色板，有些位图，比如真彩色图（24 位的 BMP ）就不需要调色板；　</span></p><p><span>　4 ： 位图数据 ，这部分的内容根据BMP 位图使用的位数不同而不同，在 24 位图中直接使用 RGB ，而其他的小于 24 位的使用调色板中颜色索引值。</span></p></li></ul></li><li><p><img src="C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20191123115410594.png" referrerpolicy="no-referrer" alt="image-20191123115410594"></p></li><li><p><span>Java虚拟机运行时的内存分配</span></p><ul><li><p><span>main函数中</span></p><ul><li><span>int i=0;—————数据段</span></li><li><span>new xxx————存放在堆里面</span></li><li><span>File file= run();————run函数返回一个指针(堆中的)赋值给file</span></li><li><span>int i=returnInt()————从寄存器中返回一个值赋值给i;</span></li></ul></li><li><p><span>类中的普通函数(无返回值)</span></p><ul><li><p><span>int i=0;————只有调用函数的时候才会有存放在栈中，函数运行结束时清除栈帧</span></p></li><li><p><span>new  xxx———计算是否能放在栈里面，如果不行就放到堆里面，函数结束时清除栈帧，</span></p><ul><li><span>如果存放在堆中的话内存被释放后会产生碎片化内存。整理起来会很麻烦</span></li></ul></li></ul></li><li><p><span>普通函数(int string duuble...)返回普通变量</span></p><ul><li><span>return i;————返回一个值到寄存器中，在由寄存器赋值给返回的位置(寄存器的速度比内存快)</span></li></ul></li><li><p><span>普通函数，返回一个对象</span></p><ul><li><span>return file;———存放在堆里面，返回时返回一个指针(堆的地址)，并且会保留存在堆中的位置</span></li></ul></li></ul></li><li><p><span>serialze</span></p><ul><li><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class  bmp_header { </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">char[2]  magic_nu;//两个字节 &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int &nbsp; len; &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">byte[4]  reserved;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">.......</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;"></div><div class="CodeMirror-gutters" style="display: none; height: 138px;"></div></div></div></pre></li><li><p><span>把一个文件的编码按照一定的格式封装起来；————————————序列化，</span></p></li><li><p><span>在主函数中解析文件的时候直接把整个类的对象传进来‘然后按照一定的格式去解析文件</span></p></li></ul></li><li><p><span>文件的储存格式分大端和小端</span></p><ul><li><p><span>根据文件的格式来判断是大端还是小端</span></p></li><li><p><span>区别</span></p><ul><li><span>大端:小的在高地址，大的在低地址，——power ARM</span></li><li><span>小端:小的在低地址，大的在高地址，———x86....</span></li></ul></li><li><p><span>文件会在编码中给出自己是大端还是小端;</span></p></li></ul></li></ul><p>&nbsp;</p></div></body>
</html>